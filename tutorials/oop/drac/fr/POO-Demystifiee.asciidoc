= PureBasic et la Programmation Orientée Objet
Dräc
v0.4, December 1, 2016: WIP Porting from HTML.
:title: PureBasic et la Programmation Orientée Objet — ou «la POO démystifiée»
:doctype: article
:encoding: utf-8
:lang: fr
:toc: left
:sectnums:
:highlightjsdir: ../hjs
:idprefix:
:idseparator: -
:icons: font
:version-label: Draft

////
==============================================================================
                                    TODOs
==============================================================================
-- Understand better punctuation marks ruls in French:
    -- use of space (or "thin space") before double pointed marks (?!:; %)
       and between a word and its surrounding quotes.
    -- Should I use “…” or «…» ?
    -- How to render "thin space" (&#8201;) in AsciiDoc?
////

.About This Tutorial
****
**CREDITS**: This is a reprint of «Dräc»’s multi-part tutorial __PureBasic et la Programmation Orientée Objet__, also knwon as __la POO démystifiée__, published in 2005  on http://drac.site.chez-alice.fr/Tutorials%20Programming%20PureBasic/POO/POO_Pourquoi.htm[drac.site.chez-alice.fr].

**LICENSE**: It was reprinted with explicit permission of the author, who released the tutorial text and source codes under https://creativecommons.org/licenses/by/4.0/deed.fr[Creative Commons Attribution]  (CC BY 4.0) in response to the permission request to reproduce it inside the https://github.com/tajmone/purebasic-archives[PureBASIC Archives].

**CHANGES**: The tutorial was ported from HTML to AsciiDoc by https://github.com/tajmone[Tristano Ajmone], who also made minor changes to code examples (either aesthetic, or minor corrections, or to ensure compatibility with latest version of PureBASIC).

First republished: 2016/11/?? — by https://github.com/tajmone[@tajmone].
****

// Website Page 1

== Pourquoi de la POO en PureBasic ?

Il peut sembler surprenant de chercher à réaliser en PureBasic, qui est un langage procédural, une représentation orientée objet, d’autant que de nombreux langages adaptés à la POO existent.

Mais que certains langages de programmation soient « Objets » et que d’autres ne le soient pas, traduit uniquement l’existence de mots-clés supplémentaires qui facilitent l’écriture de ces programmes.
Ainsi, les langages orientés-objets enrichissent la sémantique mais ne modifient en rien l’aspects de la compilation par rapport à un langage non-Objet. Ils ne font que rajouter une couche au-dessus de ce dernier.

On peut donc tout à fait en implémenter les concepts en PureBasic au prix d’une certaine rigueur de développement et de notation. C’est là que se situe l’avantage immédiat des langages Objets.

Néanmoins, la mise en œuvre de la méthode objet en PureBasic offre, outre la possibilité de programmer selon cette philosophie, l’intérêt de dévoiler certains mécanismes sous-jacents des mots-clés des langages objets.

Cet article présente une technique de programmation permettant à des projets PureBasic d’envergure de bénéficer d’une conception orienté objet. Il est entendu qu’il ne s’agit pas ici d’un cours des techniques POO et que le lecteur possède une bonne connaissance du langage PureBasic.


// Website Page 2

== Les concepts objets

La Programmation Orientée Objet introduit des concepts comme l’objet, l’héritage ou le polymorphisme.
Nous allons essayer de voir comment les principaux concepts peuvent être réalisés en PureBasic.
Mais avant cela, il nous faut définir ces concepts.

=== La notion d’objet

Un objet possède un état interne:

*   L’état est représenté par la valeur de chacun de ses composants à un instant donné,
*   Un composant est soit une valeur, soit un autre objet.

Il utilise et met à disposition des services :

*   Il interagit avec l’extérieur par l’intermédiaire de fonctions appelées méthodes

Il est unique (notion d’identité)

Un objet peut être vue de deux façons :

*   De part les services qu’il rend : vue externe (spécification). C’est le côté utilisateur,
*   De part la manière dont sont implémentés, en son sein, les services : vue interne (implémentation). C’est le côté développeur.

Du point de vu du développeur, l’objet est donc une zone mémoire contiguë contenant des informations : des variables appelées **attributs** et des fonctions appelées **méthodes**.
Le fait que l’on appelle les fonctions d’un objet des méthodes, tient au fait qu’elles sont propres à l’objet et permettent la manipulation des attributs de cet objet.

=== La notion de Classe

Il s’agit d’une extension de la notion de type que l’on trouve en PureBasic.

Dans un contexte donné, plusieurs objets peuvent posséder la même structure et le même comportement.
On les regroupe alors dans une même " Classe ".

Du point de vu du développeur, la Classe définit ce que contient un objet de cette classe : la nature de ses attributs (type de chaque variable) et ses méthodes (noms, implémentations).

Si le type d’une variable est un entier, le type d’un objet est sa Classe.

=== La notion d’instance

*   Une instance est un objet défini à partir d’une classe.
*   Un tel processus s’appelle l’instanciation.
*   Cela correspond à la déclaration de variables dans PureBasic.
*   L’objet est **normalement initialisé** dès sa création.

=== L’encapsulation

En théorie, on ne devrait pouvoir manipuler les attributs d’un objet qu’en passant par les méthodes. Cette technique, qui permet de ne rendre visible à l’utilisateur qu’une partie de l’objet, est appelée encapsulation.

L’encapsulation a comme avantage de garantir l’intégrité des attributs. En effet, c’est le développeur qui, par l’intermédiaire des méthodes mises à la disposition de l’utilisateur, maîtrise les modifications apportées à l’objet.

C’est du moins, à notre niveau ce que l’on en retiendra.

=== L’héritage

L’héritage permet de définir de nouvelles Classes en utilisant des Classes déjà existantes.

Du point de vue du développeur, cela revient à pouvoir ajouter des attributs et des méthodes à ceux existants dans une Classe pour en définir une autre, voir même à **modifier** certaines méthodes.

Il existe deux types d’héritages :

*   L’héritage simple : La nouvelle Classe est définie à partir d’une seule Classe existante
*   L’héritage multiple : La nouvelle Classe est définie à partir de plusieurs Classes existantes

Bien que possible à programmer, l’héritage multiple est complexe à mettre en œuvre et ne sera pas abordé ici.

Nous nous limiterons à l’héritage simple.

[big]##**Terminologie:**##

*   La Classe qui hérite d’une autre Classe, est souvent appelée Classe Fille
*   La Classe qui donne son héritage à une Classe Fille est souvent appelée Classe Mère.

=== La surcharge

On dit qu’une méthode est surchargée, si elle réalise des actions différentes selon la nature des objets visés.

Prenons un exemple :

Les objets suivants: cercle, rectangle et triangle sont des formes géométriques.
On peut définir pour ces objets une même Classe qu’on appellera Forme.
Les objets sont donc des instances de la classe Forme.

Si on veut afficher les objets, il faut que la classe Forme dispose d’une méthode " Dessiner ".

Ainsi doté, chaque objet dispose donc d’une méthode " Dessiner " pour s’afficher. Or, cette méthode ne peut-être la même selon que l’on veut afficher un cercle ou un rectangle.

Les objets d’une même Classe utilisent donc la même méthode " Dessiner ", mais la nature de l’objet (Rectangle, Triangle) spécifie l’implémentation de la méthode.

On dit que la méthode Dessiner est surchargée: du point de vu de l’utilisateur afficher un cercle ou un rectangle se fait de la même manière, ceci en toute transparence.

Du point de vue du développeur, l’implémentation des méthodes diffère.

Au lieu de méthode surchargée, on peut parler aussi de méthode polymorphe (ayant plusieurs formes).

=== Notion de Classe abstraite

Nous avons vu qu’une Classe regroupe la définition des attributs d’un objet ainsi que ces méthodes.
Supposons que l’on ne puisse pas donner l’implémentation d’une des méthodes de la Classe. La méthode n’est qu’un nom sans code. On parle alors de méthode abstraite.
Une Classe comportant au moins une méthode abstraite est qualifiée de Classe abstraite.

On peut se demander la raison d’être d’une classe abstraite puisque l’on ne peut créer d’objet d’une telle Classe. Les Classes abstraites permettent de définir des <<La notion de Classe,Classes d’objets>> qualifiées par opposition de concrètes. Le passage de l’une à l’autre se fait par héritage en prenant le soin de donner les implémentations nécessaires aux méthodes abstraites.

Les Classes abstraites ont donc un rôle d’interface, car qu’elles décrivent la spécification générique de toutes les Classes qui en hérite.

// Website Page 3

== Première Implémentation

Dans ce qui va suivre, nous allons voir comment les concepts objets qui viennent d’être abordés peuvent être implémentés en PureBasic.
En aucun cas cela fait référence à ce qui est programmé dans les langages objets. De plus, le propre de l’implémentation c’est de pouvoir être amélioré ou de s’adapter au besoin.
Nous proposons donc ici une de ces d’implémentations avec ses avantages et ses limites.

=== Classe concrète et Classe abstraite

Comme nous l’avons vu, la Classe définie ce que contient un objet:

*   ses attributs (type de chaque variable)
*   ses méthodes (noms, implémentation)

Si, par exemple, on veut représenter des objets Rectangle et les afficher à l’écran, on définira donc une Classe `Rectangle` possédant une méthode ``Dessiner()``.

La Classe `Rectangle` pourrait avoir la construction suivante:

// CODE CHECKED!

// Example N. 3.1-1
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle
  *Dessiner
  x1.l
  x2.l
  y1.l
  y2.l
EndStructure

Procedure Dessiner_Rectangle(*this.Rectangle)
  ; [ ...some code... ]
EndProcedure
---------------------------------------------------------------------

où ``x1``, ``x2``, `y1` et `y2` sont quatre attributs (les coordonnées des points diamétralement opposés du rectangle) et `*Dessiner` est un pointeur faisant référence à la fonction de dessin qui affiche les Rectangles.
`*Dessiner` est ici un pointeur de fonction utilisé pour contenir l’adresse de la fonction désirée : ``@Dessiner_Rectangle()``.
Il suffit d’utiliser `CallFunctionFast()` pour lancer l’exécution de la fonction ainsi référencée.

Nous voyons donc que l’instruction Structure est tout à fait adaptée à la notion de Classe:
*   Nous y trouvons la définition des attributs d’un objet : ici ``x1``, ``x2``, `y1` et `y2` sont de type entier Long.
*   Nous y trouvons la définition des méthodes : ici `Dessiner()` grâce à un pointeur de fonction.

Si la Classe ainsi définie est suivit de l’implémentation des méthodes (dans notre exemple il s’agit de la déclaration du bloc Procedire/EndProcedure de ``Dessiner_Rectangle()``), la Classe sera une Classe concrète.
Dans le cas contraire elle sera abstraite.

[IMPORTANT]
====
On appelle toujours ``*this``, le pointeur vers l’objet auquel on applique la méthode. Cette notation est appliquée dans notre exemple avec la méthode ``Dessiner_Rectangle()``.
====

=== Instanciation

Si l’on désire créer maintenant un objet `Rect1` issu de la classe ``Rectangle``, cela revient à écrire :

// CODE CHECKED!

// Example N. 3.2-1
[source,purebasic]
---------------------------------------------------------------------
Rect1.Rectangle
---------------------------------------------------------------------

Pour l’initialiser, il suffit d’écrire :

// CODE CHECKED!

// Example N. 3.2-2
[source,purebasic]
---------------------------------------------------------------------
Rect1\Dessiner = @Dessiner_Rectangle()
Rect1\x1 = 0
Rect1\x2 = 10
Rect1\y1 = 0
Rect1\y2 = 20
---------------------------------------------------------------------

Par la suite, pour dessiner l’objet ``Rect1``, on écrira:

// CODE CHECKED!

// Example N. 3.2-3
[source,purebasic]
---------------------------------------------------------------------
CallFunctionFast(Rect1\Dessiner, @Rect1)
---------------------------------------------------------------------

=== Encapsulation

Dans cette implémentation, l’encapsulation n’existe pas, tout simplement car il n’y a pas moyen de cacher les attributs ou les méthodes d’un tel objet.

En effet, il suffit d’écrire `Rect1\x1` pour accéder à l’attribut `x1` de l’objet. C’est d’ailleurs ce moyen que nous avons utilisé pour initialiser l’objet.
Nous verrons dans la deuxième implémentation, comment cela peut changer.
Cependant, cette notion, bien qu’important, n’est pas la plus essentielle pour faire de la POO.

=== Héritage

Imaginons maintenant que l’on souhaite créer une nouvelle Classe d’objet `Rectangle` capable en plus de s’effacer de l’écran.
On peut se servir de la Classe existante `Rectangle` et y adjoindre la nouvelle méthode `Effacer()` pour créer la nouvelle Classe ``Rectangle2``.

Une Classe étant une ``Structure``, nous allons profiter de la propriété qu’a une structure d’être étendue. Ainsi, la nouvelle Classe `Rectangle2` peut s’écrire :

// CODE CHECKED!

// Example N. 3.4-1
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle2 Extends Rectangle
  *Effacer
EndStructure

Procedure Effacer_Rectangle(*this.Rectangle2)
  ; [ ...some code... ]
EndProcedure
---------------------------------------------------------------------

La Classe Rectangle2 possède donc bien les membres de la Classe `Rectangle` et une nouvelle méthode ``Effacer()``.
En effet, l’instanciation d’un objet de cette Classe donne :

// CODE CHECKED!

// Example N. 3.4-2
[source,purebasic]
---------------------------------------------------------------------
Rect2.Rectangle2

Rect2\Dessiner = @Dessiner_Rectangle()
Rect2\Effacer = @Effacer_Rectangle()
Rect2\x1 = 0
Rect2\x2 = 10
Rect2\y1 = 0
Rect2\y2 = 20
---------------------------------------------------------------------

Pour utiliser les méthodes Dessiner() et Effacer() de Rect2, on procèdera de la même manière que précédemment.

Nous pouvons donc dire que Rectangle2 a hérité des propriétés de la Classe Rectangle.

[NOTE]
====
L’héritage est une forme de polymorphisme. L’objet `Rect2` peut etre vu comme un Objet de la Classe ``Rectangle``, il suffit de ne pas se servir de la méthode ``Effacer()``. Par héritage, l’objet revête donc plusieurs formes : celles des objets issus des différentes Classes Mères. On parle alors de polymorphisme d’héritage.
====

=== Surcharge

Lors de l’initialisation d’un objet, on initialise les pointeurs de fonction en leur affectant l’adresse de la méthode qui convient à l’objet.

Ainsi, pour un objet Rect de Classe ``Rectangle``, en écrivant:

// CODE CHECKED!

// Example N. 3.5-1
[source,purebasic]
---------------------------------------------------------------------
Rect1\Dessiner = @Dessiner_Rectangle()
---------------------------------------------------------------------

on peut utiliser la méthode `Dessiner()` comme suite:

// CODE CHECKED!

// Example N. 3.5-2
[source,purebasic]
---------------------------------------------------------------------
CallFunctionFast(Rect1\Dessiner, @Rect1)
---------------------------------------------------------------------

Maintenant, imaginons qu’il soit possible d’implémenter une autre méthode pour l’affichage d’un rectangle (utilisant un algorithme distinct de celui de la premiere méthode).

Appelons la ``Dessiner_Rectangle2()``:

// CODE CHECKED!

// Example N. 3.5-3
[source,purebasic]
---------------------------------------------------------------------
Procedure Dessiner_Rectangle2(*this.Rectangle)
  ; [ ...some code... ]
EndProcedure
---------------------------------------------------------------------

Il est tout à fait possible d’initialiser notre objet Rect1 avec cette nouvelle méthode sans grande peine:

// CODE CHECKED!

// Example N. 3.5-4
[source,purebasic]
---------------------------------------------------------------------
Rect1\Dessiner = @Dessiner_Rectangle2()
---------------------------------------------------------------------

Si l’on veut utiliser la méthode on écrira à nouveau:

// CODE CHECKED!

// Example N. 3.5-5
[source,purebasic]
---------------------------------------------------------------------
CallFunctionFast(Rect1\Dessiner, @Rect1)
---------------------------------------------------------------------

Nous constatons bien que dans un cas (méthode ``Dessiner_Rectangle()``) comme dans l’autre (méthode ``Dessiner_Rectangle2()``) l’utilisation de la méthode de l’objet `Rect1` est strictement identique.
Il ne nous est pas possible en effet par la seule ligne "``CallFunctionFast(Rect1\Dessiner, @Rect1)``"  de distinguer la méthode `Dessiner()` que l’objet `Rect1` utilise.
Pour y arriver, il faut remonter jusqu’à l’initialisation de l’objet.

La notion de pointeur de fonction permet donc la surcharge de la méthode `Dessiner()` de la Classe ``Rectangle``.

Il y a tout de même une limitation dans cette surcharge. L’utilisation de l’instruction `CallFunctionFast()` implique de faire attention au nombre de paramètres.

=== Conclusion :

Dans cette première implémentation, nous disposons d’un objet capable de répondre aux principaux concepts orientés objet avec certaines limitations.
Nous venons surtout de poser les bases qui vont nous servir à réaliser un objet plus complet, ceci grâce à l’instruction `Interface` de PureBasic.

== L’instruction Interface

// CODE CHECKED!

// Example N. 4-1
.Syntaxe :
[source,purebasic pseudocode]
---------------------------------------------------------------------
Interface <Nom1> [Extends <Nom2>]
  [Procedure1]
  [Procedure2]
  ...
EndInterface
---------------------------------------------------------------------

L’instruction `Interface` de PureBasic, permet de regrouper sous un même Nom (``<Nom1>`` dans l’encadré) différentes procédures.

Ex :

// CODE CHECKED!

// Example N. 4-2

[source,purebasic]
---------------------------------------------------------------------
Interface Mon_Objet
  Procedure1(x1.l, y1.l)
  Procedure2(x2.l, y2.l)
EndInterface
---------------------------------------------------------------------

Il suffit de déclarer un élément de type `Mon_Objet` pour accéder aux procédures qu’elle détient.
La déclaration se fait de la même manière que pour une `Structure` :

// Example N. 4-3

[source,purebasic]
---------------------------------------------------------------------
Objet.Mon_Objet
---------------------------------------------------------------------

Nous pouvons alors utiliser les fonctions de Objet directement comme suite:

// CODE CHECKED!

// Example N. 4-4

[source,purebasic]
---------------------------------------------------------------------
Objet\Procedure1(10, 20)
Objet\Procedure2(30, 40)
---------------------------------------------------------------------

Lancer une procedure grâce à l’instruction Interface se fait par une notation fort pratique et agréable.
En écrivant " Objet\Procedure1(10, 20) ", on lance la Procedure1() de l’élément Objet.
Cette notation est typique de la Programmation Orienté Objet.

==== Initialisation :

Comme toute déclaration d’une variable typée, il s’en suit normalement l’initialisation de la variable.
Il en est de même lorsque l’on déclare un élément dont le type provient d’une ``Interface``.

Contre toute attente, il ne suffit pas de donner le nom d’une procédure à l’intérieur du bloc `Interface : EndInterface` pour que cela fasse référence à l’implémentation de cette procédure, c’est à dire que l’on référence le bloc `Procédure : EndProcedure` de la procédure voulue.

En réalité vous pouvez renommer les procédures dans un bloc ``Interface : EndInterface``, c’est à dire donner les noms que vous voulez aux procédures que vous allez utiliser.

Comment relier alors ce nouveau nom à la vraie procédure ?

Comme pour la surcharge de méthode, la solution se trouve dans les adresses de fonctions.
Il faut voir en effet les noms contenus dans le bloc Interface/EndInterface, comme des pointeurs de fonctions auxquels on attribut les adresses des fonctions que l’on désire y mettre.

Cependant, pour initialiser les pointeurs de fonctions d’un élément typé par une ``Interface``, il faut procéder différemment qu’avec un élément typé par une ``Structure``.
Il n’est en effet pas possible d’initialiser individuellement chacun des champs définis par une Interface, car rappelez-vous que d’écrire `Objet\Procedure1()` revient à lancer une procédure.

L’initialisation se réalise indirectement en donnant à l’élément l’adresse d’une variable composée des pointeurs de fonctions préalablement initialisée.

Une telle variable est appelée table des méthods.

Ex : Si l’on reprend l’``Interface Mon_Objet``.
Considérons la `Structure` suivante de description des pointeurs de fonctions :

// CODE CHECKED!

// Example N. 4.1-1
[source,purebasic]
---------------------------------------------------------------------
Structure Mes_Methodes
  *Procedure1
  *Procedure2
EndStructure
---------------------------------------------------------------------

et la variable initialisée associée:

// CODE CHECKED!

// Example N. 4.1-2
[source,purebasic]
---------------------------------------------------------------------
Methodes.Mes_Methodes
Methodes\Procedure1 = @Ma_Procedure1()
Methodes\Procedure2 = @Ma_Procedure2()
---------------------------------------------------------------------

où `Ma_Procedure1()` et `Ma_Procedure2()` sont les implémentations des procédures que l’on veut utiliser.

Alors, l’initialisation de l’élément `Objet` de type `Mon_Objet` se fera comme suite :

// CODE CHECKED!

// Example N. 4.1-3
[source,purebasic]
---------------------------------------------------------------------
Objet.Mon_Objet = @Methodes
---------------------------------------------------------------------

Ainsi, en écrivant

// CODE CHECKED!

// Example N. 4.1-4
[source,purebasic]
---------------------------------------------------------------------
Objet\Procedure2(30, 40)
---------------------------------------------------------------------

on lance la fonction `Procedure2()` de l’élément ``Objet``, c’est à dire ``Ma_Procedure2()``.

[IMPORTANT]
====
Lorsque l’on déclare un élément typé par une interface, il est obligatoire de l’initialiser avant de se servir des procédures de l’élément. Il est donc vivement conseillé d’initialiser l’élément dès sa déclaration.
====

[IMPORTANT]
====
[[admonition-structure-interface-symetrie]]La composition de la Structure décrivant les pointeurs de fonctions, doit être le reflet exact de la composition de l’``Interface``. C’est à dire qu’elle doit comporter le même nombre de champs et respecter l’ordre pour que l’attribution entre les noms et les adresses de chaque fonction soit celle attendue. C’est seulement à ces conditions que l’élément sera correctement initialisé.
====

Pour résumer, utiliser une Interface c’est disposer:

*   d’une `Interface` décrivant les procédures que l’on veut utiliser,
*   d’une `Structure` décrivant les pointeurs d’adresses des fonctions,
*   d’une **table des méthodes**: variable initialisée issue de cette structure.

C’est aussi:

*   bénéficier d’une notation orientée objet,
*   pouvoir renommer facilement les procédures.



// Website Page 5

== Deuxième Implémentation

Dans notre première implémentation, nombres de concepts ont été traduits d’une manière plus ou moins étendue.
Nous allons voir maintenant comment on peut améliorer cette implémentation grâce à l’utilisation de l’instruction Interface.

=== Notion d’interface Objet :

Nous avons vu que la notion d’encapsulation avait comme but premier de rendre visible à l’utilisateur qu’une partie de l’objet.
La partie visible du contenu est appelée **interface**, l’autre partie cachée est appelée **implémentation**.

L’interface d’un objet est donc la seule porte d’entrée/sortie dont dispose l’utilisateur pour agir sur un objet.

C’est le rôle que l’on va donner dans notre utilisation de l’instruction Interface.

L’instruction Interface va donc nous permettre de regrouper sous un même Nom, tout ou partie des méthodes d’un objet que l’utilisateur aura le droit de manipuler.

=== Instanciation et Constructeur d’Objet

Vouloir utiliser une interface c’est d’abord se munir :

1.  d’une Interface décrivant les méthodes que l’on veut utiliser,
2.  d’une Structure décrivant les pointeurs d’adresses des fonctions correspondantes,
3.  d’une table des méthodes: variable initialisée issue de cette structure.

L’étape 1, consistant à d’écrire l’Interface d’un objet, n’est pas compliquée. Il suffit de nommer les méthodes.

Les étapes 2 et 3 sont liées. Or dans notre approche objet, nous disposons déjà de la Structure adaptée: c’est celle qui décrit la Classe d’un objet.
En effet, l’Interface et la Classe d’un objet se ressemblent: Tous deux comportent des pointeurs de fonctions.
Simplement, l’instruction Interface ne contient pas les attributs de la Classe mais seulement tout ou partie des méthodes de la Classe.

Il est donc tout à fait possible de se servir de la Classe d’un objet pour initialiser l’interface. Cette démarche est d’ailleurs des plus naturelles. Rappelons que l’interface est la partie visible de la Classe d’un objet, il est donc normal que l’interface soit déterminée par la Classe.

Voyons comment procéder.
Reprenons la Classe Rectangle2 munie des deux méthodes : Dessiner() et Effacer()

Sa Classe est la suivante

// CODE CHECKED!

// Example N. 5.2-1
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle2
  *Dessiner
  *Effacer
  x1.l
  x2.l
  y1.l
  y2.l
EndStructure

Procedure Dessiner_Rectangle(*this.Rectangle2)
  ; [ ...some code... ]
EndProcedure

Procedure Effacer_Rectangle(*this.Rectangle2)
  ; [ ...some code... ]
EndProcedure
---------------------------------------------------------------------

Définissons maintenant l’interface suivante:

// CODE CHECKED!

// Example N. 5.2-2
[source,purebasic]
---------------------------------------------------------------------
Interface Rectangle
  Dessiner()
  Effacer()
EndInterface
---------------------------------------------------------------------

Comme on veut obliger l’utilisateur à passer par l’Interface, il n’est plus question de créer un objet directement à partir de la Classe Rectangle2.

L’objet sera donc créée en écrivant :

// CODE CHECKED!

// Example N. 5.2-3
[source,purebasic]
---------------------------------------------------------------------
Rect.Rectangle
---------------------------------------------------------------------

au lieu de Rect.Rectangle2

Cependant, il ne faut pas oublier de relier l’Interface à la Classe.
Pour cela il faut initialiser l’objet Rect et il est conseillé de le faire lors de la déclaration de l’objet.
Correction faite, la bonne instruction pour déclarer l’objet via l’interface est la suivante :

// CODE CHECKED!

// Example N. 5.2-4
[source,purebasic]
---------------------------------------------------------------------
Rect.Rectangle = New_Rect(0, 10, 0, 20)
---------------------------------------------------------------------

New_Rect() est une fonction qui réalise l’opération d’initialisation.
Ce que l’on sait déjà d’elle, c’est qu’elle retourne comme valeur l’adresse mémoire contenant les adresses des fonctions utilisées par l’interface.

Voici maintenant le corps de la fonction New_Rect()

// CODE CHECKED!

// Example N. 5.2-5
[source,purebasic]
---------------------------------------------------------------------
Procedure New_Rect(x1.l, x2.l, y1.l, y2.l)
  *Rect.Rectangle2 = AllocateMemory(SizeOf(Rectangle2))

  *Rect\Dessiner = @Dessiner_Rectangle()
  *Rect\Effacer = @Effacer_Rectangle()

  *Rect\x1 = x1
  *Rect\x2 = x2
  *Rect\y1 = y1
  *Rect\y2 = y2

  ProcedureReturn *Rect
EndProcedure
---------------------------------------------------------------------

Cette fonction alloue une zone mémoire de la taille de la Classe de l’objet.
Elle initialise ensuite les méthodes puis les attributs de l’objet.
Elle se termine en retournant l’adresse de cette zone mémoire.
Comme on trouve au début de cette zone mémoire d’abord les adresses des fonctions `Dessiner_Rectangle()` et ``Effacer_Rectangle()``, on initialise effectivement l’interface.

Pour accéder aux méthodes de l’objet ``Rect``, il suffit d’écrire :

// CODE CHECKED!

// Example N. 5.2-6
[source,purebasic]
---------------------------------------------------------------------
Rect\Dessiner()
Rect\Effacer()
---------------------------------------------------------------------


On vérifie bien que :

*   la Classe `Rectangle2` permet d’initialiser l’interface de l’objet.
*   ``Rect``, déclaré via l’interface, est un objet de la Classe `Rectangle2` pouvant utiliser les méthodes `Dessiner()` et ``Effacer()``.

Nous avons donc réalisé, via l’Interface et la fonction ``New_Rect()``, l’instanciation d’un objet Rect de la Classe ``Rectangle2``.
La fonction `New_Rect()` est appelée **Constructeur** de l’objet de Classe ``Rectangle2``.

[IMPORTANT]
====
Toutes les implémentations des Méthodes (blocs ``Procedur : EndProcedure``) doivent comporter comme premier argument le pointeur `*this` de l’objet sur lequel on doit appliquer la fonction.
A l’opposé, l’argument `*this` ne doit plus apparaît au niveau de l’``Interface``. En effet, comme l’instruction nous permet d’écrire ``Rect\Dessiner()``, on sait que la méthode `Dessiner()` est celle de l’objet ``Rect``: Il n’y a pas d’ambiguïté. Tout se passe comme si l’objet `Rect` était "conscient" de son état.
====

[NOTE]
====
[[admonition-constructeur-parametres]]Le constructeur pourrait recevoir comme paramètres supplémentaires, les adresses des fonctions implémentant les méthodes. Il n’en est rien ici car on connait l’implémentation des méthodes: c’est celle de la classe. Par contre on ne connait pas l’état initial que l’utilisateur veut donner à l’objet. Il se peut donc que le constructeur comporte des paramètres pour l’initialisation des attributs.
C’est le cas ici pour `New_Rect()` demandant en entrée les coordonnées (``x1``, ``y1``) et (``x2``, ``y2``) des points diamétralement opposés du rectangle.
====

=== Initialisation d’Objet

Nous avons vu que le constructeur, après avoir alloué la place mémoire nécessaire à l’objet, initialise les différents membres de l’objet (méthodes et attributs).
On peut isoler cette opération dans une procédure à part, que le constructeur appellera.
Cette précaution permet de distinguer l’allocation mémoire de l’initialisation de l’objet. Ceci sera très utile pour mener à bien par la suite le concept d’héritage, car une seule allocation de mémoire suffit, mais plusieurs initialisations seront nécessaires.

Cependant nous séparerons l’initialisation des méthodes et celle des attributs.
En effet, l’implémentation des méthodes dépend de la classe, alors que l’initialisation des attributs dépend de l’objet lui-même (voir <<admonition-constructeur-parametres,remarque précédente>>)

Dans notre exemple, nous écrirons les deux procédures suivantes :

// CODE CHECKED!

// Example N. 5.3-1
[source,purebasic]
---------------------------------------------------------------------
Procedure Init_Mthds_Rect(*Rect.Rectangle2)
  *Rect\Dessiner = @Dessiner_Rectangle()
  *Rect\Effacer = @Effacer_Rectangle()
EndProcedure

Procedure Init_Mbers_Rect(*Rect.Rectangle2, x1.l, x2.l, y1.l, y2.l)
  *Rect\x1 = x1
  *Rect\x2 = x2
  *Rect\y1 = y1
  *Rect\y2 = y2
EndProcedure
---------------------------------------------------------------------

et le Constructeur devient:

// CODE CHECKED!

// Example N. 5.3-2
[source,purebasic]
---------------------------------------------------------------------
Procedure New_Rect(x1.l, x2.l, y1.l, y2.l)
  *Rect = AllocateMemory(SizeOf(Rectangle2))
  Init_Mthds_Rect(*Rect)
  Init_Mbers_Rect(*Rect, x1, x2, y1, y2)
  ProcedureReturn *Rect
EndProcedure
---------------------------------------------------------------------

=== Destructeur d’Objet

On associe toujours à un constructeur d’objet, son opposé : le destructeur d’objet.
Lors de la construction d’un objet, une zone mémoire a était allouée pour stocker les définitions des méthodes et des attributs.
Quant un objet n’est plus utile, il ne faut pas oublier de le détruire pour libérer la mémoire.
Ce processus se fait en utilisant une fonction appelée **Destructeur** d’objet.

Dans notre exemple d’objet de la Classe Rectangle2, le destructeur d’objet s’écrira :

// CODE CHECKED!

// Example N. 5.3-3
[source,purebasic]
---------------------------------------------------------------------
Procedure Free_Rect(*Rect)
  FreeMemory(*Rect)
EndProcedure
---------------------------------------------------------------------

et s’utilisera, comme suite:

// CODE CHECKED!

// Example N. 5.3-4
[source,purebasic]
---------------------------------------------------------------------
Free_Rect(Rect2)
---------------------------------------------------------------------

[NOTE]
====
On peut voir le Destructeur d’objet comme une méthode de l’objet. Mais pour éviter d’alourdir l’objet et garder une homogénéité avec le Constructeur, nous avons préféré le voir comme une fonction de la Classe.
====

[WARNING]
====
Détruire un objet par son Destructeur, signifie que l’on libère la place mémoire contenant les informations de l’objet mais en aucun cas on ne détruit l’infrastructure de l’objet.
Aussi, dans notre exemple, après avoir fait:

[source,purebasic]
---------------------------------------------------------------------
Free_Rect(Rect2)
---------------------------------------------------------------------

on peut toujours réutiliser Rect2 sans préciser à nouveau son type:

[source,purebasic]
---------------------------------------------------------------------
Rect2 = New_Rect(0, 10, 0, 20)
Rect2\Dessiner()
---------------------------------------------------------------------

En effet, lorsque l’on réalise l’instanciation d’un objet, comme suite :

[source,purebasic]
---------------------------------------------------------------------
Rect2.Rectangle
---------------------------------------------------------------------

on crée un objet Rect2 dont la durée de vie est assujettie aux mêmes règles que celles des variables car Rect2 est d’abord une variable : C’est une variable structurée continuant les pointeurs de fonctions des méthodes de l’objet.(voir aussi le rappel qui suit)
====

[IMPORTANT]
====
Petit rappel : La durée de vie d’une variable est liée à la durée de vie de la partie du programme où elle est déclarée :

*   Si la variable est déclarée à l’intérieur d’une fonction, sa durée de vie sera liée à celle de la fonction, c’est à dire égale au temps d’utilisation de la fonction.
*   Si la variable est déclarée en dehors de toute fonction, c’est à dire dans le corps principal du programme, sa durée de vie est liée à celle du programme
====

=== Allocations Mémoire

A chaque nouvelle instanciation, le constructeur doit allouer dynamiquement une place mémoire de la taille des informations décrivant l’objet.
Pour cela, le Constructeur peut utiliser la commande ``AllocateMemory()``, associée à la commande `FreeMemory()` pour le Destructeur.

Mais cela peut être une toute autre commande d’allocation dynamique de mémoire.
Sous OS Windows, on peut passer directement par les API par exemple.

En standard, PureBasic propose les listes chaînées qui permettent aussi d’allouer dynamiquement de la mémoire.

=== Encapsulation

Imaginons maintenant que l’on ne veuille donner à l’utilisateur seulement accès à la méthode Dessiner() de la Classe Rectangle2. On commencera par définir l’interface désirée :

// CODE CHECKED!

// Example N. 5.6-1
[source,purebasic]
---------------------------------------------------------------------
Interface Rectangle
  Dessiner()
EndInterface
---------------------------------------------------------------------

L’instanciation du nouvel objet reste la même:

// CODE CHECKED!

// Example N. 5.6-2
[source,purebasic]
---------------------------------------------------------------------
Rect.Rectangle = New_Rect()
---------------------------------------------------------------------

avec

// CODE CHECKED!

// Example N. 5.6-3
[source,purebasic]
---------------------------------------------------------------------
Procedure Init_Mthds_Rect(*Rect.Rectangle2)
  *Rect\Dessiner = @Dessiner_Rectangle()
  *Rect\Effacer = @Effacer_Rectangle()
EndProcedure

Procedure Init_Mbers_Rect(*Rect.Rectangle2, x1.l, x2.l, y1.l, y2.l)
  *Rect\x1 = x1
  *Rect\x2 = x2
  *Rect\y1 = y1
  *Rect\y2 = y2
EndProcedure

Procedure New_Rect(x1.l, x2.l, y1.l, y2.l)
  *Rect = AllocateMemory(SizeOf(Rectangle2))
  Init_Mthds_Rect(*Rect)
  Init_Mbers_Rect(*Rect, x1, x2, y1, y2)
  ProcedureReturn *Rect
EndProcedure
---------------------------------------------------------------------

car en effet, la première adresse de fonction est bien celle de la méthode Dessiner().

Maintenant, imaginons que l’on veuille donner à l’utilisateur seulement accès à la méthode Effacer(). On commencera par définir l’interface suivante:

// CODE CHECKED!

// Example N. 5.6-4
[source,purebasic]
---------------------------------------------------------------------
Interface Rectangle
  Effacer()
EndInterface
---------------------------------------------------------------------

Par contre l’instanciation du nouvel objet ne peut utiliser le constructeur New_Rect().
Dans le cas contraire, le résultat serait identique au cas précédent.

Il faut donc créer un nouveau constructeur capable de retourner l’adresse de fonction adaptée.

En voici un :

// CODE CHECKED!

// Example N. 5.6-5
[source,purebasic]
---------------------------------------------------------------------
Procedure Init_Mthds_Rect2(*Rect.Rectangle2)
  *Rect\Dessiner = @Effacer_Rectangle()
  *Rect\Effacer = @Dessiner_Rectangle()
EndProcedure

Procedure Init_Mbers_Rect(*Rect.Rectangle2, x1.l, x2.l, y1.l, y2.l)
  *Rect\x1 = x1
  *Rect\x2 = x2
  *Rect\y1 = y1
  *Rect\y2 = y2
EndProcedure

Procedure New_Rect2(x1.l, x2.l, y1.l, y2.l)
  *Rect = AllocateMemory(SizeOf(Rectangle2))
  Init_Mthds_Rect2(*Rect)
  Init_Mbers_Rect(*Rect, x1, x2, y1, y2)
  ProcedureReturn *Rect
EndProcedure
---------------------------------------------------------------------

Vous constatez qu’il a suffit d’inverser les adresses de fonction dans l’initialisation des méthodes de la Classe.
Certes, ce n’est pas très élégant de devoir affecter au champ Dessin de la Structure Rectangle2 l’adresse d’une toute autre fonction.
Si cela permet de conserver la même Structure, celle de la Classe, cela souligne aussi une chose :
Les noms des pointeurs de fonctions nous intéressent moins que leurs valeurs !
Pour gommer ce faux problème, il suffit de renommer les pointeurs de la Classe comme suite :

// CODE CHECKED!

// Example N. 5.6-6
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle2
  *Methode1
  *Methode2
  x1.l
  x2.l
  y1.l
  y2.l
EndStructure
---------------------------------------------------------------------

C’est l’Interface et le Constructeur qui donnent un sens à ces pointeurs :

*   en leur donnant un nom (rôle de l’interface)
*   en leur affectant les adresses de fonctions adéquates (rôle du constructeur)

[NOTE]
====
Malgré cette disposition concernent les noms des pointeurs de fonction, il reste bien plus pratique de conserver un nom explicite si l’on ne compte pas cacher les méthodes (ce qui est le plus courant). Cela permet de faire évoluer une Classe Mère sans retoucher à la numérotation des pointeurs des Classes Filles.
====

=== Héritage

Comme lors de notre première implémentation du concept d’héritage, nous allons profiter de la qualité qu’ont à la fois les instructions Structure et Interface d’être étendues grâce au mot-clé Extends.

Ainsi, nous passerons de la Classe Rectangle1 possédant une seule méthode Dessiner()…

// CODE CHECKED!

// Example N. 5.7-1
.Interface
[source,purebasic]
---------------------------------------------------------------------
Interface Rect1
  Dessiner()
EndInterface
---------------------------------------------------------------------

// CODE CHECKED!

// Example N. 5.7-2
.Classe
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle1
  *Methode1
  x1.l
  x2.l
  y1.l
  y2.l
EndStructure

Procedure Dessiner_Rectangle(*this.Rectangle1)
  ; [ ...some code... ]
EndProcedure

Procedure Init_Mthds_Rect1(*Rect.Rectangle1)
  *Rect\Methode1 = @Dessiner_Rectangle()
EndProcedure
---------------------------------------------------------------------

// CODE CHECKED!

// Example N. 5.7-3
.Constructeur
[source,purebasic]
---------------------------------------------------------------------
Procedure Init_Mbers_Rect1(*Rect.Rectangle1, x1.l, x2.l, y1.l, y2.l)
  *Rect\x1 = x1
  *Rect\x2 = x2
  *Rect\y1 = y1
  *Rect\y2 = y2
EndProcedure

Procedure New_Rect1(x1.l, x2.l, y1.l, y2.l)
  *Rect = AllocateMemory(SizeOf(Rectangle1))
  Init_Mthds_Rect1(*Rect)
  Init_Mbers_Rect1(*Rect, x1, x2, y1, y2)
  ProcedureReturn *Rect
EndProcedure
---------------------------------------------------------------------

…à la Classe Rectangle2, possédant 2 méthodes : Dessiner() et Effacer() en écrivant :

// CODE CHECKED!

// Example N. 5.7-4
.Interface
[source,purebasic]
---------------------------------------------------------------------
Interface Rect2 Extends Rect1
  Effacer()
EndInterface
---------------------------------------------------------------------

// CODE CHECKED!

// Example N. 5.7-5
.Classe
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle2 Extends Rectangle1
  *Methode2
EndStructure

Procedure Effacer_Rectangle(*this.Rectangle2)
  ; [ ...some code... ]
EndProcedure

Procedure Init_Mthds_Rect2(*Rect.Rectangle2)
  Init_Mthds_Rect1(*Rect)
  *Rect\Methode2 = @Effacer_Rectangle()
EndProcedure
---------------------------------------------------------------------

// CODE CHECKED!

// Example N. 5.7-6
.Constructeur
[source,purebasic]
---------------------------------------------------------------------
Procedure Init_Mbers_Rect2(*Rect.Rectangle2, x1.l, x2.l, y1.l, y2.l)
  Init_Mbers_Rect1(*Rect, x1, x2, y1, y2)
EndProcedure

Procedure New_Rect2(x1.l, x2.l, y1.l, y2.l)
  *Rect = AllocateMemory(SizeOf(Rectangle2))
  Init_Mthds_Rect2(*Rect)
  Init_Mbers_Rect2(*Rect, x1, x2, y1, y2)
  ProcedureReturn *Rect
EndProcedure
---------------------------------------------------------------------

Accomplir un héritage consiste non seulement à étendre l’``Interface`` et la Classe mais aussi à adapter l’initialisation des méthodes et des attributs.
Les deux procédures `Init_Mthds_Rect2()` et `Init_Mbers_Rect2()` font appel respectivement à l’initialisation des méthodes et à l’initialisation des attributs de la Classe `Rectangle1` (``Init_Mthds_Rect1()`` et ``Init_Mbers_Rect1()``) et non au constructeur ``New_Rect1()``.

En effet, il n’est pas question d’instancier un objet de la Classe Mère (``Rectangle1``) pour construire un objet de la Classe Fille (``Rectangle2``).
Il est question simplement d’hériter des méthodes et des attributs, ce à quoi contribue l’emploi des initialisations de la Classe Mère dans la Classe Fille.

D’autre part, on vérifie bien qu’en modifiant la Classe Mère (en ajoutant une méthode ou une variable), la Classe Fille bénéficie instantanément des changements.

L’héritage est-il pour autant correct? Non, car dans l’état actuel, il ne permet pas à l’objet de la Classe Fille (``Rectangle2``) d’utiliser la nouvelle méthode `Effacer()` !
Ceci tout simplement car le pointeur de fonction *Methode2 ne se trouve pas directement à la suite du pointeur de fonction ``*Methode1``.

Si on explicite la Structure de la Classe ``Rectangle2``, on a :

// CODE CHECKED!

// Example N. 5.7-7
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle2
  *Methode1
  x1.l
  x2.l
  y1.l
  y2.l
  *Methode2
EndStructure
---------------------------------------------------------------------

au lieu de disposer de la Structure ci-dessous, autorisant une initialisation correcte de l’interface:

// CODE CHECKED!

// Example N. 5.7-8
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle2
  *Methode1
  *Methode2
  x1.l
  x2.l
  y1.l
  y2.l
EndStructure
---------------------------------------------------------------------

Rappelez-vous qu’il faut des adresses de fonction qui se suivent et qui soient ordonnées à l’image de l’Interface (<<admonition-structure-interface-symetrie,voir remarque précédente>>)

On résout ce problème en regroupant dans une structure spécifique les méthodes entre-elles !
Il suffit alors que la Structure de la Classe garde un pointeur sur cette nouvelle structure comme le montre l’exemple suivant :

// CODE CHECKED!

// Example N. 5.7-9
.Interface
[source,purebasic]
---------------------------------------------------------------------
Interface Rect1
  Dessiner()
EndInterface
---------------------------------------------------------------------

// Example N. 5.7-10
.Classe
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle1
  *Methodes
  x1.l
  x2.l
  y1.l
  y2.l
EndStructure

Procedure Dessiner_Rectangle(*this.Rectangle1)
  ; [ ...some code... ]
EndProcedure

Structure Mthds_Rect1
  *Methode1
EndStructure

Procedure Init_Mthds_Rect1(*Mthds.Mthds_Rect1)
  *Mthds\Methode1 = @Dessiner_Rectangle()
EndProcedure

Mthds_Rect1. Mthds_Rect1
Init_Mthds_Rect1(@Mthds_Rect1)
---------------------------------------------------------------------

// Example N. 5.7-11
.Constructeur
[source,purebasic]
---------------------------------------------------------------------
Procedure Init_Mbers_Rect1(*Rect.Rectangle1, x1.l, x2.l, y1.l, y2.l)
  *Rect\x1 = x1
  *Rect\x2 = x2
  *Rect\y1 = y1
  *Rect\y2 = y2
EndProcedure

Procedure New_Rect1(x1.l, x2.l, y1.l, y2.l)
  Shared Mthds_Rect1
  *Rect.Rectangle1 = AllocateMemory(SizeOf(Rectangle1))
  *Rect\Methodes = @Mthds_Rect1
  Init_Mbers_Rect1(*Rect, x1, x2, y1, y3)
  ProcedureReturn *Rect
EndProcedure
---------------------------------------------------------------------

La structure `Mthds_Rect1` décrit tous les pointeurs de fonction des méthodes de la Classe.
S’en suit la déclaration de la variable Mthds_Rect1 de type Mthds_Rect1 ainsi que son initialisation grace à Init_Mthds_Rect1().

La variable Mthds_Rect1 est appelée **la table des méthodes** de la class car elle contient l’ensemble des adresses des méthodes de la class.

Cet ensemble constitue la description complète des méthodes de la Classe.

La structure ``Rectangle1``, comporte maintenant un pointeur ``*Methodes``, initialisé par le constructeur en donnant l’adresse de la variable ``Mthds_Rect1``.

[TIP]
====
L’expression

// CODE CHECKED!

// Example N. 5.7-12
[source,purebasic]
---------------------------------------------------------------------
Mthds_Rect1.Mthds_Rect1
Init_Mthds_Rect1(@Mthds_Rect1)
---------------------------------------------------------------------

peut etre condensée en

// CODE CHECKED!

// Example N. 5.7-13
[source,purebasic]
---------------------------------------------------------------------
Init_Mthds_Rect1(@Mthds_Rect1.Mthds_Rect1)
---------------------------------------------------------------------

====

L’héritage est alors possible car en étendant la Structure Methd_Rect1 en une nouvelle Methd_Rect2, les adresses de fonction vont se suivre:

// CODE CHECKED!

// Example N. 5.7-14
.Interface
[source,purebasic]
---------------------------------------------------------------------
Interface Rect2 Extends Rect1
  Effacer()
EndInterface
---------------------------------------------------------------------

// CODE CHECKED!

// Example N. 5.7-15
.Classe
[source,purebasic]
---------------------------------------------------------------------
Structure Rectangle2 Extends Rectangle1
EndStructure

Procedure Effacer_Rectangle(*this.Rectangle2)
  ; [ ...some code... ]
EndProcedure

Structure Mthds_Rect2 Extends Mthds_Rect1
  *Methode2
EndStructure

Procedure Init_Mthds_Rect2(*Mthds.Mthds_Rect2)
  Init_Mthds_Rect1(*Mthds)
  *Mthds\Methode2 = @Effacer_Rectangle()
EndProcedure

Mthds_Rect2. Mthds_Rect2
Init_Mthds_Rect2(@Mthds_Rect2)
---------------------------------------------------------------------

// CODE CHECKED!

// Example N. 5.7-16
.Constructeur
[source,purebasic]
---------------------------------------------------------------------
Procedure Init_Mbers_Rect2(*Rect.Rectangle2 , x1.l, x2.l, y1.l, y2.l)
  Init_Mbers_Rect1(*Rect, x1, x2, y1, y2)
EndProcedure

Procedure New_Rect2(x1.l, x2.l, y1.l, y2.l)
  Shared Mthds_Rect2
  *Rect.Rectangle2 = AllocateMemory(SizeOf(Rectangle2))
  *Rect\Methodes = @Mthds_Rect2
  Init_Mbers_Rect2(*Rect, x1, x2, y1, y2)
  ProcedureReturn *Rect
EndProcedure
---------------------------------------------------------------------


Dans cet exemple, la Structure `Rectangle2` est vide, ce qui n’est pas gênant en soit.
Deux raisons à cela :

*   D’abord le pointeur `*Methodes` n’a besoin d’exister qu’une seule fois et ceci dans la Classe Mère.
*   Ensuite, nous n’avons pas souhaitez ajouter d’attributs supplémentaires, auquel cas elle aurait dû les contenir.

[NOTE]
====
Le fait d’avoir externalisé l’initialisation des méthodes hors du constructeur combiné à des pointeurs de fonctions disponiblent dans une variable fixe a trois avantages:

*   Les pointeurs de fonction des méthodes de la Classe sont initialisés une fois pour toute et non plus à chaque instanciation d’un objet
*   Les objets instanciés ne disposent plus que d’un pointeur vers les pointeurs des méthodes: le gain en place mémoire est substantiel.
*   Comme tous les objets pointent vers les mêmes pointeurs de fonction, cela garantit un comportement identique des objets de même Classe.
====

=== Accesseur et Modifieur d’Objet

En passant par l’``Interface``, il n’est possible de manipuler que des méthodes de l’objet.
L’interface encapsule donc entièrement les attributs des objets, c’est à dire qu’elle les cache.
Pour accéder aux attributs, soit pour les lires, soit pour les modifier, il faut donc disposer de méthodes spécifiques et les mettre à disposition de l’utilisateur.
Les méthodes qui permettent de lire les attributs d’un objet sont appelées les **Accesseur** de l’objet.
Les méthodes qui permettent de modifier les attributs d’un objet sont appelées les **Modifieurs** de l’objet.

Dans notre exemple de Classe ``Rectangle1``, si nous voulons lire la valeur de l’attribut var2, on créera l’Accesseur suivant:

// CODE CHECKED!

// Example N. 5.8-1
[source,purebasic]
---------------------------------------------------------------------
Procedure Get_var2(*this.Rectangle1)
  ProcedureReturn *this\var2
EndProcedure
---------------------------------------------------------------------

De même, pour modifier la valeur de l’attribut var2, on écrira le Modifieur suivant

// CODE CHECKED!

// Example N. 5.8-2
[source,purebasic]
---------------------------------------------------------------------
Procedure Set_var2(*this.Rectangle1, value)
  *this\var2 = value
EndProcedure
---------------------------------------------------------------------

Comme les Accesseurs et les Modifieurs n’existent que pour permettre à l’utilisateur de modifier tout ou partie des attributs d’un objet, ils sont obligatoirement présents dans l’interface.


// TODO: MISSING LINK

[NOTE]
====
Voir l’annexe http://drac.site.chez-alice.fr/Tutorials%20Programming%20PureBasic/POO/POO_Annexes.htm#Optimisations_Get_Set[Optimisation] du tutorial pour étudier de quelle manière on peut optimiser les performances des accesseurs et des modifieurs lors de l’exécution
====

// Website Page 6

// ============== REVISED UP TO THIS POINT! ==============

